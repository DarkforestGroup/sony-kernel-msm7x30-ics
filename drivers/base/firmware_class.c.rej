--- drivers/base/firmware_class.c
+++ drivers/base/firmware_class.c
@@ -150,27 +139,28 @@
 	int loading = simple_strtol(buf, NULL, 10);
 	int i;
 
-	mutex_lock(&fw_lock);
-
-	if (!fw_priv->fw)
-		goto out;
-
 	switch (loading) {
 	case 1:
-		firmware_free_data(fw_priv->fw);
-		memset(fw_priv->fw, 0, sizeof(struct firmware));
-		/* If the pages are not owned by 'struct firmware' */
+		mutex_lock(&fw_lock);
+		if (!fw_priv->fw) {
+			mutex_unlock(&fw_lock);
+			break;
+		}
+		vfree(fw_priv->fw->data);
+		fw_priv->fw->data = NULL;
 		for (i = 0; i < fw_priv->nr_pages; i++)
 			__free_page(fw_priv->pages[i]);
 		kfree(fw_priv->pages);
 		fw_priv->pages = NULL;
 		fw_priv->page_array_size = 0;
 		fw_priv->nr_pages = 0;
+		fw_priv->fw->size = 0;
 		set_bit(FW_STATUS_LOADING, &fw_priv->status);
+		mutex_unlock(&fw_lock);
 		break;
 	case 0:
 		if (test_bit(FW_STATUS_LOADING, &fw_priv->status)) {
-			vunmap(fw_priv->fw->data);
+			vfree(fw_priv->fw->data);
 			fw_priv->fw->data = vmap(fw_priv->pages,
 						 fw_priv->nr_pages,
 						 0, PAGE_KERNEL_RO);
@@ -194,8 +181,7 @@
 		fw_load_abort(fw_priv);
 		break;
 	}
-out:
-	mutex_unlock(&fw_lock);
+
 	return count;
 }
 
@@ -479,7 +465,8 @@
 	if (!firmware) {
 		dev_err(device, "%s: kmalloc(struct firmware) failed\n",
 			__func__);
-		return -ENOMEM;
+		retval = -ENOMEM;
+		goto out;
 	}
 
 	for (builtin = __start_builtin_fw; builtin != __end_builtin_fw;
@@ -493,14 +480,6 @@
 		return 0;
 	}
 
-	read_lock_usermodehelper();
-
-	if (WARN_ON(usermodehelper_is_disabled())) {
-		dev_err(device, "firmware: %s will not be loaded\n", name);
-		retval = -EBUSY;
-		goto out;
-	}
-
 	if (uevent)
 		dev_info(device, "firmware: requesting %s\n", name);
 
@@ -538,7 +517,6 @@
 	kfree(firmware);
 	*firmware_p = NULL;
 out:
-	read_unlock_usermodehelper();
 	return retval;
 }
 
