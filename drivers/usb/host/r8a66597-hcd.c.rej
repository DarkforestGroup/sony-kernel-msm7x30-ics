--- drivers/usb/host/r8a66597-hcd.c
+++ drivers/usb/host/r8a66597-hcd.c
@@ -407,7 +396,7 @@
 
 /* this function must be called with interrupt disabled */
 static void free_usb_address(struct r8a66597 *r8a66597,
-			     struct r8a66597_device *dev, int reset)
+			     struct r8a66597_device *dev)
 {
 	int port;
 
@@ -419,13 +408,7 @@
 	dev->state = USB_STATE_DEFAULT;
 	r8a66597->address_map &= ~(1 << dev->address);
 	dev->address = 0;
-	/*
-	 * Only when resetting USB, it is necessary to erase drvdata. When
-	 * a usb device with usb hub is disconnect, "dev->udev" is already
-	 * freed on usb_desconnect(). So we cannot access the data.
-	 */
-	if (reset)
-		dev_set_drvdata(&dev->udev->dev, NULL);
+	dev_set_drvdata(&dev->udev->dev, NULL);
 	list_del(&dev->device_list);
 	kfree(dev);
 
@@ -1048,7 +1017,7 @@
 	struct r8a66597_device *dev = r8a66597->root_hub[port].dev;
 
 	disable_r8a66597_pipe_all(r8a66597, dev);
-	free_usb_address(r8a66597, dev, 0);
+	free_usb_address(r8a66597, dev);
 
 	start_root_hub_sampling(r8a66597, port, 0);
 }
@@ -2069,7 +2041,7 @@
 				spin_lock_irqsave(&r8a66597->lock, flags);
 				dev = get_r8a66597_device(r8a66597, addr);
 				disable_r8a66597_pipe_all(r8a66597, dev);
-				free_usb_address(r8a66597, dev, 0);
+				free_usb_address(r8a66597, dev);
 				put_child_connect_map(r8a66597, addr);
 				spin_unlock_irqrestore(&r8a66597->lock, flags);
 			}
@@ -2212,7 +2184,7 @@
 			rh->port |= (1 << USB_PORT_FEAT_RESET);
 
 			disable_r8a66597_pipe_all(r8a66597, dev);
-			free_usb_address(r8a66597, dev, 1);
+			free_usb_address(r8a66597, dev);
 
 			r8a66597_mdfy(r8a66597, USBRST, USBRST | UACT,
 				      get_dvstctr_reg(port));
