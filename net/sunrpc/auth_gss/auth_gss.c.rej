--- net/sunrpc/auth_gss/auth_gss.c
+++ net/sunrpc/auth_gss/auth_gss.c
@@ -548,13 +548,13 @@
 	}
 	inode = &gss_msg->inode->vfs_inode;
 	for (;;) {
-		prepare_to_wait(&gss_msg->waitqueue, &wait, TASK_KILLABLE);
+		prepare_to_wait(&gss_msg->waitqueue, &wait, TASK_INTERRUPTIBLE);
 		spin_lock(&inode->i_lock);
 		if (gss_msg->ctx != NULL || gss_msg->msg.errno < 0) {
 			break;
 		}
 		spin_unlock(&inode->i_lock);
-		if (fatal_signal_pending(current)) {
+		if (signalled()) {
 			err = -ERESTARTSYS;
 			goto out_intr;
 		}
@@ -644,22 +644,7 @@
 	p = gss_fill_context(p, end, ctx, gss_msg->auth->mech);
 	if (IS_ERR(p)) {
 		err = PTR_ERR(p);
-		switch (err) {
-		case -EACCES:
-			gss_msg->msg.errno = err;
-			err = mlen;
-			break;
-		case -EFAULT:
-		case -ENOMEM:
-		case -EINVAL:
-		case -ENOSYS:
-			gss_msg->msg.errno = -EAGAIN;
-			break;
-		default:
-			printk(KERN_CRIT "%s: bad return from "
-				"gss_fill_context: %ld\n", __func__, err);
-			BUG();
-		}
+		gss_msg->msg.errno = (err == -EAGAIN) ? -EAGAIN : -EACCES;
 		goto err_release_msg;
 	}
 	gss_msg->ctx = gss_get_ctx(ctx);
@@ -717,18 +702,17 @@
 	struct rpc_inode *rpci = RPC_I(inode);
 	struct gss_upcall_msg *gss_msg;
 
-restart:
 	spin_lock(&inode->i_lock);
-	list_for_each_entry(gss_msg, &rpci->in_downcall, list) {
+	while (!list_empty(&rpci->in_downcall)) {
 
-		if (!list_empty(&gss_msg->msg.list))
-			continue;
+		gss_msg = list_entry(rpci->in_downcall.next,
+				struct gss_upcall_msg, list);
 		gss_msg->msg.errno = -EPIPE;
 		atomic_inc(&gss_msg->count);
 		__gss_unhash_msg(gss_msg);
 		spin_unlock(&inode->i_lock);
 		gss_release_msg(gss_msg);
-		goto restart;
+		spin_lock(&inode->i_lock);
 	}
 	spin_unlock(&inode->i_lock);
 
@@ -1274,8 +1258,9 @@
 	rqstp->rq_release_snd_buf = priv_release_snd_buf;
 	return 0;
 out_free:
-	rqstp->rq_enc_pages_num = i;
-	priv_release_snd_buf(rqstp);
+	for (i--; i >= 0; i--) {
+		__free_page(rqstp->rq_enc_pages[i]);
+	}
 out:
 	return -EAGAIN;
 }
